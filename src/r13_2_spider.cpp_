/* S-TopCoder Round 13 Problem 2
 * 插头 DP + Path Reconstruction
 */
#include <algorithm>
#include <cassert>
#include <cfloat>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#include <bitset>
#include <queue>

#ifdef BENCH
#define DBG 1 // modify this for enabling/disable debug
#else
#define DBG 0
#endif // BENCH

#define D(...) do { if (DBG) fprintf(stdout, __VA_ARGS__); } while (0)

#define CLR(x) memset(x, 0, sizeof x);
#define CLRN(x, n) memset(x, 0, (n)*sizeof x[0]);
#define CLRVN(x, v, n) memset(x, v, (n)*sizeof x[0]);
#define REP(v,n) for(int v=0;v<n;v++)
#define FOR(v,a,b) for(int v=a;v<=b;v++)
#define every(iter, iterable) \
	typeof((iterable).begin()) iter = (iterable).begin(); iter != (iterable).end(); iter++

const int maxn = 100010;
const int m = 2; // two columns
const int bits = 4; // each state needs 3 bits (may set to 4 bits to make it faster)
const int mask = (1 << bits) - 1;
const int maxhash = (m + 1) * (1 << bits); // three states on two columns
const int hashrng = (1 << (bits * (m + 1)));

int n;
int s1r, s1c, s2r, s2c, e1r, e1c, e2r, e2c;
int now, p, q;
int cur, lnum, unum, tot, val, left, up;

// Hash table for state values

// base8 states x 2 lines
//    0: no line
//    1: line_1
//    2: line_2
//    4: two lines so far

enum CState {
	NOTHING = 0,
	LINE_1 = 1, // this is a plug for LINE 1
	LINE_2 = 2, // this is a plug for LINE 2
	MASK = 3,
	TWO_LINES = 4, // there are two lines on and before this cell
};

template<int HASHSZ, int HASHRNG>
struct Hash {
   int ID[HASHRNG]; // bucket id of the hash key
   int key[HASHSZ], val[HASHSZ]; // key and value of the bucket
   int cnt;
   Hash() : cnt(0) { CLRVN(ID,0xFF,HASHRNG); }
   void clear(){
       REP(i,cnt)
           ID[key[i]] = -1;
       cnt = 0;
   }
   void update(int k, int v){
       if (ID[k] == -1) {
           ID[k] = cnt++;
           key[ID[k]] = k;
           val[ID[k]] = v;
       }else{
           val[ID[k]] += v; // add to current value in hash table
       }
   }
   int getval(int idx){return val[idx];}
   int getsta(int idx){return key[idx];}
};

Hash<maxhash,hashrng> T[2];

bool isStart(int i, int j) {
	return (i + 1 == s1c && j + 1 == s1r) || (i + 1 == s2c && j + 1 == s2r);
}

bool isEnd(int i, int j) {
	return (i + 1 == e1c && j + 1 == e1r) || (i + 1 == e2c && j + 1 == e2r);
}

int getcode(int tot, int bline, int rline) {
	int b = tot | bline;
	int r = tot | rline;
	int st = cur | (b << p) | (r << q);
	return st;
}

void encode(int tot, int bline, int rline) {
    int st = getcode(tot, bline, rline);
    D("encode(%x, %d)\n", st, val);
    T[now].update(st, val);
}

void addNewLine(int j, bool first, bool ep) {
    assert(tot != TWO_LINES);
    int newtot = first ? 0 : TWO_LINES;
    int line = first ? LINE_1 : LINE_2;
    if (ep && !left && j != 1) {
        D("addline newtot=%d bottom=0 right=%d\n", newtot, line);
        encode(newtot, 0, line); // horizontal
    }
    if (!up) {
    	D("addline newtot=%d bottom=%d right=0\n", newtot, line);
    	encode(newtot, line, 0); // vertical
    }
    if (first) {
    	D("addline newtot=%d bottom=%d right=%d\n", newtot, line, line);
    	encode(newtot, line, line); // top-left corner
    }
}

void endLine(int tot, bool ep) {
    if (left || up) { /* cannot apply to null input */
    	D("endline tot=%d\n",tot);
    	encode(tot, 0, 0); // no output plugs
    }
}

void mergeLine() {
    /*
     * |     |
     * |     |
     * +----[+] merge
     */
    encode(0, 0, 0); // reduce total to 1 (represented as 0)
    D("mergeline tot=0 bottom=0 right=0\n");
}

void extendLine(int j, bool close) {
    if (j == 0) {
        // left cell
        if (left) return;
        if (!up) return;
        assert(up != 0);
        if (!close) {
            encode(tot, unum, 0); // down
            D("extendline tot=%d bottom=%d right=0\n", unum);
        }
        encode(tot, 0, unum); // right
        D("extendline tot=%d bottom=0 right=%d\n", tot, unum);
    } else {
        // right cell
        if (!close && (left ^ up)) { // excluding merging case
        	int num = left ? lnum : unum;
            D("extendline tot=%d bottom=%d right=0\n", tot, num);
            encode(tot, num, 0); // down
        }
    }
}

void solve() {
	int lst = 1;
	now = 0;
	T[now].clear();
	// Initial state(s)
	T[now].update(0, 1);
	for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {
		lst = now;
		now ^= 1;
		T[now].clear();
		p = (m - j) * bits, q = p - bits;

		for (int k = 0; k < T[lst].cnt; k++) {
			val = T[lst].getval(k);
			int pre = T[lst].getsta(k);

			if (j == 0) {
				if (mask & pre) continue; // right border should be clear
				pre >>= bits;
			}

			left = (pre >> p) & mask, up = (pre >> q) & mask;
			cur = pre & ~(mask << p) & ~(mask << q);

			lnum = left & MASK;
			unum = up & MASK;
			tot = left & TWO_LINES;

			D("(%d,%d) pre=%x lnum=%d unum=%d tot=%d val=%d\n", i, j, pre, lnum, unum, tot, val);

			// Add line
			bool oneLine = !tot;
			bool isEndPt = isStart(i,j) || isEnd(i,j);

			if (oneLine && (isEndPt || i == 0))
				addNewLine(j, i == 0 && j == 0, isEndPt);

			// End line
			if (!(i == 0 && j == 0) && (isEndPt || i == n - 1))
				endLine(tot, isEndPt);

			// Merge line
			bool canMergeLine = (j == 1) && lnum != unum && lnum && unum;
			if (canMergeLine)
				mergeLine();

			// Extend line
			if (i == n - 1) {
			    // Bottom row
			    extendLine(j, true);
			} else
			    extendLine(j, false); // TODO cycle top and bottom rows
		}
	}
	int c1 = T[now].ID[0];
	printf("%d\n", T[now].val[c1]);
}

int main() {
#if BENCH
    freopen("files/r13_2_sample.txt","r",stdin);
#endif
	int T;

	scanf("%d", &T);
	for (int tc = 0; tc < T; tc++) {
		scanf("%d", &n);
		scanf("%d%d%d%d", &s1r, &s1c, &s2r, &s2c);
		scanf("%d%d%d%d", &e1r, &e1c, &e2r, &e2c);
		D("----Test case #%d----\n", tc+1);
		solve();
	}
	return 0;
}
