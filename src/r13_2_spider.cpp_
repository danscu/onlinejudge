/* S-TopCoder Round 13 Problem 2
 * 插头 DP + Path Reconstruction
 */
#include <algorithm>
#include <cassert>
#include <cfloat>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#include <bitset>
#include <queue>

#ifdef BENCH
#define DBG 1 // modify this for enabling/disable debug
#else
#define DBG 0
#endif // BENCH

#define D(...) do { if (DBG) fprintf(stderr, __VA_ARGS__); } while (0)

#define CLR(x) memset(x, 0, sizeof x);
#define CLRN(x, n) memset(x, 0, (n)*sizeof x[0]);
#define CLRVN(x, v, n) memset(x, v, (n)*sizeof x[0]);
#define REP(v,n) for(int v=0;v<n;v++)
#define FOR(v,a,b) for(int v=a;v<=b;v++)
#define every(iter, iterable) \
	typeof((iterable).begin()) iter = (iterable).begin(); iter != (iterable).end(); iter++

const int maxn = 100010;
const int m = 2; // two columns
const int bits = 4; // each state needs 3 bits (may set to 4 bits to make it faster)
const int mask = (1 << bits) - 1;
const int maxhash = (m + 1) * (1 << bits); // three states on two columns

int n;
int s1r, s1c, s2r, s2c, e1r, e1c, e2r, e2c;
int now, p, q;
int cur, lnum, unum, tot, val, left, up;

// Hash table for state values

// base8 states x 2 lines
//    0: no contour
//    1: open contour
//    2: close contour
//    3: open and close contour (independent branch)
//    0 - 3: one line, 4 - 7: two lines (so far)

enum CState {
	NOTHING = 0,
	OPEN = 1, // left or open
	CLOSE = 2, // right or close
	IND = 3, // independent
	MASK = 3,
	LINE_2 = 4, // this is a plug on LINE 2
	TWO_LINES = 8, // there are two lines on and before this cell
};

template<int HASHSZ>
struct Hash {
   int ID[HASHSZ]; // bucket id of the hash key
   int key[HASHSZ], val[HASHSZ]; // key and value of the bucket
   int cnt;
   Hash() : cnt(0) { CLRVN(ID,-1,HASHSZ); }
   void clear(){
       REP(i,cnt)
           ID[key[i]] = -1;
       cnt = 0;
   }
   void update(int k, int v){
       if (ID[k] == -1) {
           ID[k] = cnt++;
           key[ID[k]] = k;
           val[ID[k]] = v;
       }else{
           val[ID[k]] += v; // add to current value in hash table
       }
   }
   int getval(int idx){return val[idx];}
   int getsta(int idx){return key[idx];}
};

Hash<maxhash> T[2];

bool isStart(int i, int j) {
	return (i + 1 == s1c && j + 1 == s1r) || (i + 1 == s2c && j + 1 == s2r);
}

bool isEnd(int i, int j) {
	return (i + 1 == e1c && j + 1 == e1r) || (i + 1 == e2c && j + 1 == e2r);
}

int encode(int tot, int bline, int bstat, int rline, int rstat) {
    int b = tot | bline | bstat;
    int r = tot | rline | rstat;
    return cur | (b << p) | (r << q);
}

void addNewLine(bool first, bool ep) {
    assert(tot != TWO_LINES);
    int tot = first ? 0 : TWO_LINES;
    int line = first ? 0 : LINE_2;
    if (ep)
        T[now].update(encode(tot, 0, 0, line, IND), val); // horizontal
    T[now].update(encode(tot, line, IND, 0, 0), val); // vertical
}

void endLine(int tot, bool ep) {
    T[now].update(encode(tot, 0, 0, 0, 0), val); // no output plugs
}

void mergeLine() {
    /*
     * |     |
     * |     |
     * +----[+] merge
     */
    T[now].update(encode(0, 0, 0, 0, 0), val); // reduce total to 1
}

void extendLine(int j, bool close) {
    if (j == 0) {
        // left cell
        if (left) return;
        if (!up) return;
        assert(up == IND);
        if (!close)
            T[now].update(encode(tot, unum, IND, 0, 0), val); // down
        T[now].update(encode(tot, 0, 0, unum, IND), val); // right
    } else {
        // right cell
        if (!close && (left ^ up)) { // excluding merging case
            T[now].update(encode(tot, unum, IND, 0, 0), val); // down
        }
    }
}

void solve() {
	int lst = 1;
	now = 0;
	T[now].clear();
	// Initial state(s)
	T[now].update(0, 1);
	for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {
		lst = now;
		now ^= 1;
		T[now].clear();
		p = (m - j) * bits, q = p - bits;

		for (int k = 0;k < T[lst].cnt;k ++) {
			val = T[lst].getval(k);
			int pre = T[lst].getsta(k);

			if (j == 0) {
				if (mask & pre) continue; // right border should be clear
				pre >>= bits;
			}

			left = (pre >> p) & mask, up = (pre >> q) & mask;
			cur = pre & ~(mask << p) & ~(mask << q);

			lnum = left & LINE_2;
			unum = up & LINE_2;
			tot = left & TWO_LINES;

			left &= MASK;
			up &= MASK;

			// Add line
			bool oneLine = !tot;
			bool isEndPt = isStart(i,j) || isEnd(i,j);

			if (oneLine && (isEndPt || i == 0))
				addNewLine(i == 0 && j == 0, isEndPt);

			// End line
			if (!(i == 0 && j == 0) && (isEndPt || i == n - 1))
				endLine(tot, isEndPt);

			// Merge line
			bool canMergeLine = (j == 1) && lnum != unum && left == IND && up == IND;
			if (canMergeLine)
				mergeLine();

			// Extend line
			if (i == n - 1) {
			    // Bottom row
			    extendLine(j, false);
			} else
			    extendLine(j, true); // TODO cycle top and bottom rows
		}
	}
	int nn = T[now].ID[encode(TWO_LINES, 0, NOTHING, 0, NOTHING)];
	if (nn != -1)
	    printf("%d\n", nn);
}

int main() {
#if BENCH
    freopen("files/r13_2_sample.txt","r",stdin);
#endif
	int T;

	scanf("%d", &T);
	for (int tc = 0; tc < T; tc++) {
		scanf("%d", &n);
		scanf("%d%d%d%d", &s1r, &s1c, &s2r, &s2c);
		scanf("%d%d%d%d", &e1r, &e1c, &e2r, &e2c);
		solve();
	}
	return 0;
}
